<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>YouTube Livestreams</title>

  <!-- PT Sans -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=PT+Sans:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body {
      font-family: 'PT Sans', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      margin: 0;
      padding: 1rem;
      background: #fff;
    }

    h3 {
      margin-top: 2rem;
      font-size: 1.25rem;
    }

    .stream-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 1rem;
    }

    .stream {
      border: 1px solid #ddd;
      border-radius: 4px;
      overflow: hidden;
      text-decoration: none;
      color: #000;
      background: #fafafa;
      display: block;
    }

    .stream img {
      width: 100%;
      display: block;
    }

    .stream-content {
      padding: 0.75rem;
    }

    .title {
      font-weight: bold;
      margin-bottom: 0.25rem;
    }

    .date {
      font-size: 0.85rem;
      color: #555;
    }

    .message {
      grid-column: 1 / -1;
      color: #555;
      padding: 0.5rem 0;
    }
  </style>
</head>

<body>

  <h3>More Upcoming Events</h3>
  <div id="upcoming" class="stream-list"></div>

  <h3>Recordings of Previous Events</h3>
  <div id="past" class="stream-list"></div>

  <script>
    const API_KEY = "AIzaSyDvflaf2WrXoTPnj1-cDHYWhCD_pMJnhoY";
    const CHANNEL_ID = "UC7Do00lxLh7l4WwXLl96P5A";

    // Requirements
    const PAST_DISPLAY_LIMIT = 24;     // show only 24 past events
    const PAST_FETCH_LIMIT = 50;       // only fetch most recent 50 by published date (your preference)
    const PAGE_SIZE = 50;              // max allowed for search.list/videos.list

    function formatDate(isoDate) {
      if (!isoDate) return "Date unavailable";
      const d = new Date(isoDate);
      return d.toLocaleString(undefined, { dateStyle: "medium", timeStyle: "short" });
    }

    function showMessage(container, text) {
      container.innerHTML = `<div class="message">${text}</div>`;
    }

    function createCard(video, streamIsoDate) {
      const videoId = video.id; // videos.list returns string ID
      const snippet = video.snippet || {};
      const thumbs = snippet.thumbnails || {};
      const thumbUrl =
        (thumbs.medium && thumbs.medium.url) ||
        (thumbs.high && thumbs.high.url) ||
        (thumbs.default && thumbs.default.url) ||
        "";

      const link = document.createElement("a");
      link.className = "stream";
      link.href = `https://www.youtube.com/watch?v=${videoId}`;
      link.target = "_blank";
      link.rel = "noopener noreferrer";

      link.innerHTML = `
        ${thumbUrl ? `<img src="${thumbUrl}" alt="">` : ""}
        <div class="stream-content">
          <div class="title">${snippet.title || "Untitled stream"}</div>
          <div class="date">${formatDate(streamIsoDate)}</div>
        </div>
      `;

      return link;
    }

    /**
     * Fetch livestream video IDs from search.list.
     * - eventType: "upcoming" | "completed"
     * - limit: number of IDs to collect (Infinity for unlimited)
     *
     * NOTE: order=date sorts by published date (closest proxy), which you requested.
     */
    async function fetchLivestreamIds(eventType, limit = Infinity) {
      const ids = [];
      let pageToken = "";

      while (ids.length < limit) {
        const maxResults = Math.min(PAGE_SIZE, limit === Infinity ? PAGE_SIZE : (limit - ids.length));

        const url =
          "https://www.googleapis.com/youtube/v3/search" +
          `?part=snippet` +
          `&channelId=${encodeURIComponent(CHANNEL_ID)}` +
          `&eventType=${encodeURIComponent(eventType)}` +
          `&type=video` +
          `&order=date` +
          `&maxResults=${maxResults}` +
          (pageToken ? `&pageToken=${encodeURIComponent(pageToken)}` : "") +
          `&key=${encodeURIComponent(API_KEY)}`;

        const res = await fetch(url);
        const data = await res.json();

        if (!data.items || data.items.length === 0) break;

        for (const item of data.items) {
          const vid = item?.id?.videoId;
          if (vid) ids.push(vid);
          if (ids.length >= limit) break;
        }

        pageToken = data.nextPageToken;
        if (!pageToken) break;
      }

      return ids;
    }

    /**
     * Fetch full details for a list of video IDs (snippet + liveStreamingDetails).
     */
    async function fetchVideoDetails(videoIds) {
      const results = [];
      const chunkSize = 50;

      for (let i = 0; i < videoIds.length; i += chunkSize) {
        const chunk = videoIds.slice(i, i + chunkSize);
        const url =
          "https://www.googleapis.com/youtube/v3/videos" +
          `?part=snippet,liveStreamingDetails` +
          `&id=${encodeURIComponent(chunk.join(","))}` +
          `&key=${encodeURIComponent(API_KEY)}`;

        const res = await fetch(url);
        const data = await res.json();

        if (data.items && data.items.length) results.push(...data.items);
      }

      return results;
    }

    /**
     * Render streams ordered by STREAM date:
     * - Upcoming: scheduledStartTime (ascending)
     * - Completed: actualStartTime (descending), fallback to scheduledStartTime
     */
    async function renderStreams(eventType, containerId, displayLimit = Infinity, fetchLimit = Infinity) {
      const container = document.getElementById(containerId);
      container.innerHTML = "";

      try {
        // 1) IDs from search.list
        const ids = await fetchLivestreamIds(eventType, fetchLimit);

        if (!ids.length) {
          showMessage(container, "We regularly add new events. Please check back to see what we have scheduled.");
          return;
        }

        // 2) Details from videos.list
        const videos = await fetchVideoDetails(ids);

        // 3) Build array with stream date
        const mapped = videos.map(v => {
          const live = v.liveStreamingDetails || {};
          let streamDate;

          if (eventType === "upcoming") {
            streamDate = live.scheduledStartTime;
          } else {
            // completed: use actualStartTime where possible
            streamDate = live.actualStartTime || live.scheduledStartTime;
          }

          return { video: v, streamDate };
        }).filter(x => x.streamDate); // keep only items with a meaningful stream date

        if (!mapped.length) {
          showMessage(container, "No livestream dates were found for these videos.");
          return;
        }

        // 4) Sort by stream date
        mapped.sort((a, b) => {
          const tA = new Date(a.streamDate).getTime();
          const tB = new Date(b.streamDate).getTime();
          // Upcoming: soonest first; Completed: most recent first
          return eventType === "upcoming" ? (tA - tB) : (tB - tA);
        });

        // 5) Apply display limit
        const finalList = mapped.slice(0, displayLimit);

        // 6) Render cards
        finalList.forEach(item => container.appendChild(createCard(item.video, item.streamDate)));

      } catch (err) {
        console.error(err);
        showMessage(container, "Sorry â€” there was a problem loading livestreams right now.");
      }
    }

    // Upcoming: unlimited
    renderStreams("upcoming", "upcoming", Infinity, Infinity);

    // Past: fetch 50 most recently published (proxy), then sort by actual stream time and show 24
    renderStreams("completed", "past", PAST_DISPLAY_LIMIT, PAST_FETCH_LIMIT);
  </script>

</body>
</html>
